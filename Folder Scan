import os
import time
import hashlib
import heapq
from difflib import SequenceMatcher
import sys


# Progress Bar Utilities


def progress_bar(current, total, bar_length=40):
    filled = int(bar_length * current / total)
    bar = "#" * filled + "-" * (bar_length - filled)
    percent = (current / total) * 100
    sys.stdout.write(f"\rScanning files: [{bar}] {percent:5.1f}%")
    sys.stdout.flush()


# Utilities


def sha256_file(path):
    try:
        h = hashlib.sha256()
        with open(path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                h.update(chunk)
        return h.hexdigest()
    except:
        return None

def text_preview(path, limit=5000):
    try:
        with open(path, "r", errors="ignore") as f:
            return f.read(limit)
    except:
        return ""

def file_age_days(path):
    now = time.time()
    last_access = os.path.getatime(path)
    return (now - last_access) / 86400


# A* Heuristic


def heuristic(file_info):
    score = 0

    # Age heuristic
    age = file_info["age"]
    if age > 180:
        score += 5
    elif age > 90:
        score += 3
    elif age > 30:
        score += 1

    # Duplicate heuristic
    if file_info["is_exact_duplicate"]:
        score += 6

    if file_info["similarity"] > 0.90:
        score += 4
    elif file_info["similarity"] > 0.75:
        score += 2

    # Risky file types
    risky_ext = [".docx", ".xlsx", ".py", ".c", ".cpp"]
    if file_info["extension"] in risky_ext:
        score -= 5

    return -score


# A* Decision


ACTIONS = ["keep", "archive", "delete"]

def a_star_decide(file_info):
    pq = []
    visited = set()
    start = ("keep", 0)
    heapq.heappush(pq, (heuristic(file_info), start))

    while pq:
        cost, (action, depth) = heapq.heappop(pq)

        if action not in visited:
            visited.add(action)

            if depth == 1:
                return action

            for next_action in ACTIONS:
                next_state = (next_action, depth + 1)
                heapq.heappush(pq, (heuristic(file_info), next_state))

    return "keep"


def beam_search_decide(file_info, beam_width=3, max_depth=5):
    # Initial state: action="keep", depth=0
    # Beam stores tuples of (score, action, depth)
    beam = [(heuristic(file_info), "keep", 0)]

    for _ in range(max_depth):
        candidates = []
        for score, action, depth in beam:
            if depth >= 1:
                # Based on A* logic, depth 1 is where we make the decision
                return action

            for next_action in ACTIONS:
                # In this existing logic, heuristic depends only on file_info,
                # but we maintain the structure for beam search.
                new_score = heuristic(file_info)
                candidates.append((new_score, next_action, depth + 1))

        if not candidates:
            break

        # Sort by score (lower is better in this heuristic)
        # heuristic returns -score, so more negative is "better" if we want high score actions first?
        # A* uses heapq (min heap), so it prioritizes lowest numbers (most negative).
        candidates.sort(key=lambda x: x[0])

        # Prune to beam width
        beam = candidates[:beam_width]

    # If we exit loop, return best option from current beam
    if beam:
        return beam[0][1]
    return "keep"


# Main Folder Scan


def scan_folder(root, strategy="astar"):
    start_time = time.time()
    print(f"Scanning: {root}\n")

    all_files = []

    # First pass: count files for progress bar
    for dirpath, _, filenames in os.walk(root):
        for name in filenames:
            all_files.append(os.path.join(dirpath, name))

    total_files = len(all_files)
    if total_files == 0:
        print("No files found.")
        return []

    hash_map = {}
    previews = {}
    files = []

    # Second pass: gather metadata with progress bar
    for i, path in enumerate(all_files):
        progress_bar(i + 1, total_files)

        ext = os.path.splitext(path)[1].lower()
        age = file_age_days(path)
        h = sha256_file(path)
        preview = text_preview(path)

        previews[path] = preview

        if h not in hash_map:
            hash_map[h] = []
        hash_map[h].append(path)

        files.append({
            "path": path,
            "hash": h,
            "extension": ext,
            "age": age,
            "preview": preview
        })

    print("\nCalculating duplicate & similarity scores...")

    # Compute duplicates & similarity
    total_files_count = len(files)
    for i, f in enumerate(files):
        progress_bar(i + 1, total_files_count, bar_length=30)
        h = f["hash"]
        f["is_exact_duplicate"] = len(hash_map[h]) > 1

        max_sim = 0
        for other in files:
            if other["path"] == f["path"]:
                continue
            sim = SequenceMatcher(None, f["preview"], other["preview"]).ratio()
            if sim > max_sim:
                max_sim = sim

        f["similarity"] = max_sim

    print(f"\n\nRunning AI {strategy.upper()} decision engine...\n")

    results = []
    for f in files:
        if strategy == "beam":
            action = beam_search_decide(f)
        else:
            action = a_star_decide(f)
        results.append((f["path"], action, f["age"], f["is_exact_duplicate"], f["similarity"]))

    end_time = time.time()
    duration = end_time - start_time
    hours = int(duration // 3600)
    minutes = int((duration % 3600) // 60)
    seconds = duration % 60
    print(f"\nScan completed in {hours}h {minutes}m {seconds:.2f}s")

    return results



# Run


if __name__ == "__main__":
    folder = os.path.expanduser("~/Downloads")
    
    print("Choose decision strategy:")
    print("1. A* Search")
    print("2. Beam Search")
    
    while True:
        choice = input("Enter 1 or 2: ").strip()
        if choice in ["1", "2"]:
            break
        print("Invalid input. Please enter 1 or 2.")
    
    strategy = "beam" if choice == "2" else "astar"
    
    results = scan_folder(folder, strategy=strategy)

    print("\n--- RESULTS ---")
    for path, action, age, dup, sim in results:
        print(f"\nFile: {path}")
        print(f"  Suggested: {action.upper()}")
        print(f"  Age: {age:.1f} days")
        print(f"  Exact Duplicate: {dup}")
        print(f"  Similarity Score: {sim:.2f}")
